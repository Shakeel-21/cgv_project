import*as THREE from"three";import*as CANNON from"cannon-es";import*as script from"./script.js";import*as objects from"./objects.js";import*as camera from"./camera.js";import{OrbitControls}from"three/examples/jsm/controls/OrbitControls.js";import woodTextureImage from"../img/woodenfloor.jpg";import walltextureImage from"../img/wall.jpg";import ceilingtextureImage from"../img/Ceiling.jpg";import{FBXLoader}from"three/examples/jsm/loaders/FBXLoader.js";import{FirstPersonControls}from"three/examples/jsm/controls/FirstPersonControls.js";import{PointerLockControls}from"three/examples/jsm/controls/PointerLockControls.js";const prevTime=performance.now();export const controls=new PointerLockControls(camera.currentCamera,document.body);let raycaster=objects.raycaster,velocity=new THREE.Vector3;const direction=new THREE.Vector3,vertex=new THREE.Vector3;let moveForward=!1,moveBackward=!1,moveLeft=!1,moveRight=!1;class BasicCharacterControllerProxy{constructor(t){this._animations=t}get animations(){return this._animations}}class BasicCharacterController{constructor(t){this._Init(t)}_Init(t){this._params=t,this._decceleration=new THREE.Vector3(-5,-.25,-5),this._acceleration=new THREE.Vector3(100,1,100),this._velocity=new THREE.Vector3(0,0,0),this._animations={},this._input=new BasicCharacterControllerInput,this._stateMachine=new CharacterFSM(new BasicCharacterControllerProxy(this._animations)),this._LoadModels()}_LoadModels(){(new FBXLoader).load("ALEX.fbx",(t=>{t.position.y=-30,t.rotation.y=10,t.scale.setScalar(.1),t.traverse((t=>{t.castShadow=!0})),this._target=t,this._params.scene.add(this._target),this._mixer=new THREE.AnimationMixer(this._target),this._manager=new THREE.LoadingManager,this._manager.onLoad=()=>{this._stateMachine.SetState("idle")};const e=(t,e)=>{const a=e.animations[0],o=this._mixer.clipAction(a);this._animations[t]={clip:a,action:o}},a=new FBXLoader(this._manager);a.load("Walking.fbx",(t=>{e("walk",t)})),a.load("WalkingBackwards.fbx",(t=>{e("back",t)})),a.load("Idle.fbx",(t=>{e("idle",t)})),a.load("WalkLeft.fbx",(t=>{e("left",t)})),a.load("WalkRight.fbx",(t=>{e("right",t)}))}))}Update(t){if(camera.currentCamera===camera.camera){if(!this._target)return;this._stateMachine.Update(t,this._input),velocity=this._velocity;const e=new THREE.Vector3(velocity.x*this._decceleration.x,velocity.y*this._decceleration.y,velocity.z*this._decceleration.z);e.multiplyScalar(t),e.z=Math.sign(e.z)*Math.min(Math.abs(e.z),Math.abs(velocity.z)),velocity.add(e);const a=this._target,o=this._params.camera,i=new THREE.Vector3;o.getWorldDirection(i),i.y=0;const r=this._acceleration.clone(),n=new THREE.Vector3;n.copy(i);const s=new THREE.Vector3(i.z,0,-i.x);moveForward&&(velocity.z+=r.z*t),moveBackward&&(velocity.z-=r.z*t),moveRight&&(velocity.x-=r.x*t),moveLeft&&(velocity.x+=r.x*t),a.position.add(n.normalize().multiplyScalar(velocity.z*t)),a.position.add(s.normalize().multiplyScalar(velocity.x*t)),a.rotation.y=Math.atan2(i.x,i.z),o.position.copy(a.position),o.position.y+=20,this._mixer&&this._mixer.update(t)}else if(camera.currentCamera===camera.topDownCamera){if(!this._target)return;this._stateMachine.Update(t,this._input);const e=this._velocity,a=new THREE.Vector3(e.x*this._decceleration.x,e.y*this._decceleration.y,e.z*this._decceleration.z);a.multiplyScalar(t),a.z=Math.sign(a.z)*Math.min(Math.abs(a.z),Math.abs(e.z)),e.add(a);const o=this._target,i=new THREE.Quaternion,r=new THREE.Vector3,n=o.quaternion.clone(),s=this._acceleration.clone();moveForward&&(e.z+=s.z*t),moveBackward&&(e.z-=s.z*t),moveLeft&&(r.set(0,1,0),i.setFromAxisAngle(r,4*Math.PI*t*(.5*this._acceleration.y)),n.multiply(i)),moveRight&&(r.set(0,1,0),i.setFromAxisAngle(r,4*-Math.PI*t*(.5*this._acceleration.y)),n.multiply(i)),o.quaternion.copy(n);const c=new THREE.Vector3;c.copy(o.position);const l=new THREE.Vector3(0,0,1);l.applyQuaternion(o.quaternion),l.normalize();const m=new THREE.Vector3(1,0,0);m.applyQuaternion(o.quaternion),m.normalize(),m.multiplyScalar(e.x*t),l.multiplyScalar(e.z*t),o.position.add(l),o.position.add(m),c.copy(o.position),this._mixer&&this._mixer.update(t)}}}class BasicCharacterControllerInput{constructor(){this._Init()}_Init(){document.addEventListener("keydown",(t=>this._onKeyDown(t)),!1),document.addEventListener("keyup",(t=>this._onKeyUp(t)),!1);const t=document.getElementById("blocker"),e=document.getElementById("instructions");document.addEventListener("click",(function(){controls.lock()})),controls.addEventListener("lock",(function(){e.style.display="none",t.style.display="none"})),controls.addEventListener("unlock",(function(){t.style.display="block",e.style.display=""})),objects.scene.add(controls.getObject())}_onKeyDown(t){switch(t.keyCode){case 87:moveForward=!0;break;case 65:moveLeft=!0;break;case 83:moveBackward=!0;break;case 68:moveRight=!0}}_onKeyUp(t){switch(t.keyCode){case 87:moveForward=!1;break;case 65:moveLeft=!1;break;case 83:moveBackward=!1;break;case 68:moveRight=!1}}}class FiniteStateMachine{constructor(){this._states={},this._currentState=null}_AddState(t,e){this._states[t]=e}SetState(t){const e=this._currentState;if(e){if(e.Name==t)return;e.Exit()}const a=new this._states[t](this);this._currentState=a,a.Enter(e)}Update(t,e){this._currentState&&this._currentState.Update(t,e)}}class CharacterFSM extends FiniteStateMachine{constructor(t){super(),this._proxy=t,this._Init()}_Init(){this._AddState("idle",IdleState),this._AddState("walk",WalkState),this._AddState("back",BackState),this._AddState("left",LeftState),this._AddState("right",RightState)}}class State{constructor(t){this._parent=t}Enter(){}Exit(){}Update(){}}class WalkState extends State{constructor(t){super(t)}get Name(){return"walk"}Enter(t){const e=this._parent._proxy._animations.walk.action;if(t){const a=this._parent._proxy._animations[t.Name].action;e.enabled=!0,e.time=0,e.setEffectiveTimeScale(1),e.setEffectiveWeight(1),e.crossFadeFrom(a,.5,!0),e.play()}else e.play()}Exit(){}Update(t,e){moveForward||this._parent.SetState("idle")}}class BackState extends State{constructor(t){super(t)}get Name(){return"back"}Enter(t){const e=this._parent._proxy._animations.back.action;if(t){const a=this._parent._proxy._animations[t.Name].action;e.enabled=!0,e.time=0,e.setEffectiveTimeScale(1),e.setEffectiveWeight(1),e.crossFadeFrom(a,.5,!0),e.play()}else e.play()}Exit(){}Update(t,e){moveBackward||this._parent.SetState("idle")}}class LeftState extends State{constructor(t){super(t)}get Name(){return"left"}Enter(t){const e=this._parent._proxy._animations.left.action;if(t){const a=this._parent._proxy._animations[t.Name].action;e.enabled=!0,e.time=0,e.setEffectiveTimeScale(1),e.setEffectiveWeight(1),e.crossFadeFrom(a,.5,!0),e.play()}else e.play()}Exit(){}Update(t,e){moveLeft||this._parent.SetState("idle")}}class RightState extends State{constructor(t){super(t)}get Name(){return"right"}Enter(t){const e=this._parent._proxy._animations.right.action;if(t){const a=this._parent._proxy._animations[t.Name].action;e.enabled=!0,e.time=0,e.setEffectiveTimeScale(1),e.setEffectiveWeight(1),e.crossFadeFrom(a,.5,!0),e.play()}else e.play()}Exit(){}Update(t,e){moveRight||this._parent.SetState("idle")}}class IdleState extends State{constructor(t){super(t)}get Name(){return"idle"}Enter(t){const e=this._parent._proxy._animations.idle.action;if(t){const a=this._parent._proxy._animations[t.Name].action;e.time=0,e.enabled=!0,e.setEffectiveTimeScale(1),e.setEffectiveWeight(1),e.crossFadeFrom(a,.5,!0),e.play()}else e.play()}Exit(){}Update(t,e){moveForward&&this._parent.SetState("walk"),moveBackward&&this._parent.SetState("back"),moveRight&&this._parent.SetState("right"),moveLeft&&this._parent.SetState("left")}}export var _controls;export function _LoadAnimatedModel(){const t={camera:camera.currentCamera,scene:objects.scene};_controls=new BasicCharacterController(t)}